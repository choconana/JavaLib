# Spring框架

- [SpringMVC](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/SpringMVC-Principle)
- [SpringCloud](https://github.com/dyc87112/SpringCloud-Learning)

## [IoC](https://javadoop.com/post/spring-ioc#toc_1)

**IoC容器用来管理被注解标注的类的实例，在程序需要用得到的时候，返回对应的实例**

![1600333512928](assets\IoC容器的作用.png)

### 流程

![1600418386948](D:\JavaLib\assets\SpringIoC流程.png)

#### 1. 创建Bean前的准备

##### ① prepareRefresh()

准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符；

#### 2. (最重要)加载并注册Bean: `obtainFreshBeanFactory()`

* 这一步完成后，配置文件就会**解析**成一个个`Bean`定义，注册到`BeanFactory`中的`beanDefinitionMap`；

```java
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap(256);
```

* 此时，Bean**还没有初始化**，只是**配置信息都提取**出来了

1. 关闭旧的 `BeanFactory `(如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等；
2. 返回刚刚创建的`BeanFactory`；

![1600449643134](assets\SpringIoC之加载并注册Bean.png)

##### refreshBeanFactory()

1. 如果当前`ApplicationContext`加载过`BeanFactory`，就销毁所有`Bean`，关闭`BeanFactory`；
2. 初始化一个`DefaultListableBeanFactory beanFactory = createBeanFactory()`；
3. 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用`customizeBeanFactory(beanFactory)`；
4. 根据配置，加载 Bean 到 BeanFactory 中`loadBeanDefinitions(beanFactory)`;

##### customizeBeanFactory(beanFactory)

* 配置是否允许 BeanDefinition 覆盖、是否允许循环引用；
* 覆盖：定义 bean 时使用了**相同的 id 或 name**，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在**同一配置文件**中重复了，会**抛错**，但是如果**不是同一配置文件**中，会发生**覆盖**；
* 默认情况下，Spring 允许循环依赖；

##### loadBeanDefinitions(beanFactory)

* 解析XML配置文件，或者扫描包路径下的类，并通过反射获取被标注的配置类中的信息，以便在初始化阶段装配到`Bean`中；

#### 3. 初始化前的工作

##### ③ prepareBeanFactory(beanFactory)

设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean；

##### ④ postProcessBeanFactory(beanFactory)

这里是提供给子类的扩展点，到这里的时候，**所有的 Bean 都加载、注册完成**了，但是都还**没有初始化**；

##### ⑤ invokeBeanFactoryPostProcessors(beanFactory)

调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法；

##### ⑥ registerBeanPostProcessors(beanFactory)

注册 `BeanPostProcessor `的实现类，注意看和 `BeanFactoryPostProcessor `的区别；
		此接口两个方法: `postProcessBeforeInitialization` 和 `postProcessAfterInitialization`；
 		两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化；

##### 国际化和事件广播

##### ⑦ onRefresh()

* 钩子方法；
* 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）；

#### 4. Bean的初始化

* 在这初始化前，`BeanFactory`已经创建完成，并且所有的实现了 `BeanFactoryPostProcessor`接口的需要前置处理的 `Bean` 都已经初始化， Spring 已经“手动”注册了一些与环境和系统属性等有关的特殊 Bean，如 `environment`、`systemProperties` 等。

![1600427896218](assets\初始化Bean流程.png)

##### ⑧ finishBeanFactoryInitialization(beanFactory)

* 初始化所有的 `singleton beans`（**lazy-init除外**）;
* 初始化的动作包装在`beanFactory.getBean(...) `中；

1. 通过`this.beanDefinitionNames`获取所有的`beanNames`；
2. 在循环中，根据`beanName`初始化所有**非懒加载**的`singleton beans`；

###### 1. getBean(BeanName)

```java
public Object getBean(String name) throws BeansException {
   return doGetBean(name, null, null, false);
}
```

###### 2. doGetBean()

1. 根据`beanName`检查是否已经创建过了；

   ~~~java
   Object sharedInstance = getSingleton(beanName);
   ~~~

2. 如果已经创建并且`args`不为空，就获取这个`bean`；

3.  否则就创建新的`bean`；

4. 如果存在循环依赖，则抛出异常，否则就先注册依赖关系，并初始化被依赖的`bean`；

5. 创建`bean`，`createBean(beanName, mbd, args)`；

###### 3. createBean()

1. 确保 BeanDefinition 中的 Class 被加载；

~~~java
Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
	mbdToUse = new RootBeanDefinition(mbd);
	mbdToUse.setBeanClass(resolvedClass);
}
~~~

2. 创建`bean`，`Object beanInstance = doCreateBean(beanName, mbdToUse, args)`

###### 4. (解决循环依赖)doCreateBean()

1. 判断`beanName`是不是`FactoryBean`，不是就去**初始化`bean`：`createBeanInstance()`**；

   ```java
   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
       instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
       // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说
       instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   ```

2. **解决循环依赖**，将`bean`放入三级缓存中；

   ```java
   this.addSingletonFactory(beanName, () -> {
       return this.getEarlyBeanReference(beanName, mbd, bean);
   });
   ```

   ![1589340629038](assets\循环依赖解决方案.png)

   ​		**A在执行`populateBean()`之前会通过`addSingletonFactory` 放入三级缓存中，当A要装配B，B也要装配A时，会再次去获取A，此时就通过`getSingleton`进入到三级缓存中，通过`singletonFactory.getObject()`获得A的实例，然后放入二级缓存，并清除三级缓存，B拿到A就执行`populateBean()`后面的逻辑，最终得到完备的B，并放入一级缓存，表明彻底完成实例B的创建，然后返回给A，最终A也完成了实例化。**

   * `prototype`循环依赖无法解决，因为Spring容器不对`prototype`进行缓存，因此无法提前暴露一个创建中的Bean；但`prototype`和`singleton`的循环依赖可以解决；

   * 由于解决的时候，A对象已经创建出来(**调用了构造器**)，如果是**构造器的循环依赖**，Spring自身是无法解决的，可以在构造方法的参数前加上`@Lazy`实现延迟加载来解决此问题:
     * 发现需要B,查询字段b的所有注解,发现有`@lazy`注解,那么就**不直接创建B**了,而是使用动态代理创建一个**代理类B**；

   ~~~java
   @Component
   public class CircularDepencyA {
    
       private CircularDepB circB;
    
       @Autowired
       public CircularDepA(@Lazy CircularDepB circB) {
           this.circB = circB;
       }
   }
   ~~~

   

3. 初始化`bean`的实例；

   1. 属性装配：`populateBean(beanName, mbd, instanceWrapper)`；
   2. 处理 bean 初始化完成后的各种回调：`initializeBean(beanName, exposedObject, mbd)`；

##### ⑨ finishRefresh()

最后，广播事件，ApplicationContext 初始化完成；

#### 异常处理

```java
// Destroy already created singletons to avoid dangling resources.
// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源
destroyBeans();

// Reset 'active' flag.
cancelRefresh(ex);

// 把异常往外抛
throw ex;
```

#### ⑩ resetCommonCaches()

* 在`finally{}`中；
* 缓存清除；

#### `singleton`和`prototype`

当你需要**全局的唯一标识**的时候可以用singleton,而且singleton只创建一个对象,系统消耗资源小.但是用**singleton可能会有线程安全的问题**，这个时候就需要用到prototype 。**考虑并发的问题，建议都用prototype**。

## AOP

### 动态代理

* 代理模式：使用**代理对象来代替对真实对象(real object)的访问**，这样就可以在**不修改原目标对象**的前提下，提供额外的功能操作，扩展目标对象的功能。
* 静态代理：在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。
  * 缺点：对目标对象的**每个方法**的增强都是手动完成的，**非常不灵活**（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）；
* 动态代理：从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的；
  * 优点：更加灵活，不需要针对每个目标类都单独创建一个代理类，并且也不是要必须实现接口，可以直接代理实现类；

#### JDK动态代理

**在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。**

* 使用步骤：

  1. 自定义一个JDK动态代理接口及其实现类；

  2. 然后去实现`InvocationHandler `，并重写`invoke()`；

     * **通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。** 可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

     ```java
     public interface InvocationHandler {
     
         /**
          * 当你使用代理对象调用方法的时候实际会调用到这个方法
          * @param proxy   动态生成的代理类
     	 * @param method  与代理类对象调用的方法相对应
     	 * @param args 	  当前 method 方法的参数
          */
         public Object invoke(Object proxy, Method method, Object[] args)
             throws Throwable;
     }
     ```

  3. 将自定义的代理类作为`Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`的第三个参数，该方法会**创建代理对象**；

  4. 获取代理对象：获取代理对象的工厂类

     ```java
     public class JdkProxyFactory {
         public static Object getProxy(Object target) {
             return Proxy.newProxyInstance(
                     target.getClass().getClassLoader(), // 目标类的类加载
                 	// 代理需要实现的接口，可指定多个
                     target.getClass().getInterfaces(),  
                	 	// 代理对象对应的自定义 InvocationHandler
                     new DebugInvocationHandler(target)   
             );
         }
     }
     ```

  5. 使用

     ```java
     SmsService smsService = (SmsService) JdkProxyFactory.getProxy(new SmsServiceImpl());
     smsService.send("java");
     ```

* 缺点：只能代理**实现了接口的类**，用CGLIB机制来避免；

#### CGLIB动态代理

**[CGLIB](https://github.com/cglib/cglib)(*Code Generation Library*)是一个基于[ASM](http://www.baeldung.com/java-asm)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。**CGLIB 通过**继承方式**实现代理。

**在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。**

* 使用步骤：

  1. 自定义一个类；

  2. 然后去实现方法拦截器`MethodInterceptor`，并重写`intercept()`，跟`invoke()`类似；

     ```java
     public interface MethodInterceptor
     extends Callback{
         // 拦截被代理类中的方法
         /**
          * @param obj         被代理的对象（需要增强的对象）
          * @param method      被拦截的方法（需要增强的方法）
          * @param args        方法入参
          * @param methodProxy 用于调用原始方法
          */
         public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,
                                    MethodProxy proxy) throws Throwable;
     }
     ```

  3. 获取代理类；

     ```java
     import net.sf.cglib.proxy.Enhancer;
     
     public class CglibProxyFactory {
     
         public static Object getProxy(Class<?> clazz) {
             // 创建动态代理增强类
             Enhancer enhancer = new Enhancer();
             // 设置类加载器
             enhancer.setClassLoader(clazz.getClassLoader());
             // 设置被代理类
             enhancer.setSuperclass(clazz);
             // 设置方法拦截器
             enhancer.setCallback(new DebugMethodInterceptor());
             // 创建代理类
             return enhancer.create();
         }
     }
     ```

  4. 使用；

     ```java
     AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);
     aliSmsService.send("java");
     ```

#### JDK 动态代理和 CGLIB 动态代理对比

1. **JDK 动态代理只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此**不能代理声明为 final 类型的类和方法**。
2. 就二者的**效率**来说，大部分情况都是 **JDK 动态代理更优秀**，随着 JDK 版本的升级，这个优势更加明显。

## SpringBoot

* 理念：**约定优于配置**

### 自动装配

* 实现：使用`@SpringBootApplication `；
* 特点：
  1. 内嵌`servlet`容器，应用无需打包成war格式，可以直接以jar格式运行；
  2. 提供了多个可选择的starter以简化maven依赖管理；
  3. 无需配置XML配置文件，减少配置时间，提高开发效率；
  4. 提供了一整套对应用状态的监控与管理的功能模块（引入`spring-boot-starter-actuator`），包括应用的线程信息、内存信息、应用健康状态等；

#### [原理](https://sylvanassun.github.io/2018/01/08/2018-01-08-spring_boot_auto_configure/)

* `@Conditional`：`Spring4`提供的新特性，根据特定的条件来创建`Bean`：

  1. 在`Spring`的配置文件中是否设置了某个特定的值；
  2. 是否存在特定的系统属性；
  3. 在`Spring`容器中是否已经注册了某种类型的`Bean`，没有就注册到容器；
  4. 在类路径中是否存在指定的类，没有就注册到容器；

  **自定义条件类通过实现`Condition`接口，然后加入到配置类中，并在配置类上声明`@Conditional`，最后可以根据自定义的条件注册到`Bean`；**

  ~~~java
  public class UserDAOBeanNotPresentsCondition implements Condition {
  	@Override
  	public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata) {
  		UserDAO userDAO = conditionContext.getBeanFactory().getBean(UserDAO.class);
  		return (userDAO == null);
  	}
  }
  ~~~

* `@SpringBootApplication`：`@Configuration` + **`@EnableAutoConfiguration`** + `@ComponentScan`;

  ![1600101289206](assets\springboot自动装配流程.png)





# MySQL

## MyISAM和Innodb的区别

1. **是否支持行级锁** : MyISAM 只有**表级锁(**table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,**默认为行级锁**。
2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是**性能**，**每次查询具有原子性**,其执行速度比InnoDB类型更快，但是**不提供事务支持**。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
   * InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！；
3. **是否支持外键：** MyISAM不支持，而InnoDB支持。
4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;**MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作**;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

## 索引



## MVCC

MVCC (Multiversion Concurrency Control)，即**多版本并发控制技术**,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把**数据库的行锁与行的多个版本结合起来**，只需要很小的开销,就可以实现**非锁定读**，从而大大提高数据库系统的并发性能。

* MVCC特点：
  * **每行**数据都存在一个版本，**每次数据更新时都更新该版本**
  * **修改时复制**出当前版本随意修改，各个事务之间无干扰
  * **保存时比较**版本号，如果成功（commit），则覆盖原记录；失败则放弃复制（rollback）

  每行都有版本号，保存时根据版本号决定是否成功，听起来含有**乐观锁**的味道；

## 连接池

* 如果不用数据库连接池，一次sql查询请求会经过以下步骤：
  1. 和`MySQL server`建立`TCP`连接：
     * 三次握手；
  2. `MySQL`权限认证：
     1. `Server`向`Client`发送密钥；
     2. `Client`使用密钥加密用户名、密码等信息，将加密后的报文发送给`Server`；
     3. `Server`根据`Client`请求包，验证是否是合法用户，然后给`Client`发送认证结果；
  3. `Client`发送`SQL`语句；
  4. `Server`返回语句执行结果；
  5. `MySQL`关闭；
  6. `TCP`连接断开；
     * 四次挥手；
* 不使用连接池的话，为了执行一条 SQL，会花很多时间在**安全认证、网络IO**上，如果使用连接池，执行一条 SQL **就省去了建立连接和断开连接所需的额外开销**。
* 用`connection.close()`不会直接关掉连接，而是被连接池回收，实现复用；

# [消息队列](https://adjava.netlify.app/#/./docs/high-concurrency/why-mq)

- 主要使用场景：解耦、异步、限流削峰；

- 缺点：系统可用性降低，复杂度提高，有消息丢失的风险，数据一致性问题：强一致性变为最终一致性；

- 保证高可用：1. 主从；2. 数据分片保存到多个节点，选一个leader节点与消费者对接；

- 保证消息不被**重复消费**：每个消息带有一个offset，消费者定期把消费过的offset提交上去，但由于重启、宕机等问题，仍可能存在重复消费；但最重要的是保持**幂等性**，不管数据重复多少次，要确保对应的数据是唯一的或者不会改变的。

  - 保证幂等性：

    1. 根据**主键查询**，是否数据已经存在，存在就不必再写入；
    2. 写入Redis，**天然幂等性**；**(怎么保证?)**
    3. 每条数据中保存一个**全局唯一Id**，根据id去redis中查找，没有就写入，消费；有就不再消费处理同一条数据；
    4. 通过数据库的**唯一键**保证重复数据不会重复插入多条；

    ​            

- 保证消息**可靠传输**：

  1. 生产者弄丢数据：
     1. [rocketmq](https://blog.csdn.net/LO_YUN/article/details/101673893)：
        1. msg -> rocketmq (不可被消费)，发送失败，回滚；
        2. 发送成功，生产者执行本地事务，失败则回滚；
        3. 执行成功，生产者**返回一个commit状态**给rocketmq，如果rocketmq迟迟收不到返回的结果，这条消息状态变为**unkown**，然后回调服务接口，**查询**这条消息是commit还是rollback；
        4. rocketmq**确认消息**为commit，消费者才可以消费到这条消息；
        5. 消费者操作数据库，执行自己的事务；
        6. 消费者成功消费后返回一个ACK消息给rocketmq，如果成功消费则显示消费成功，否则rocketmq会重发消息给消费者；
  2. MQ弄丢数据：开启rabbitmq持久化，将消息写入后会持久化到磁盘，mq挂了，恢复后自动读取之前存储的数据；
  3. 消费者弄丢数据：看1中第6条；

- 保证消息的**顺序性**：每个partition中分n个内存queue，具有相同key的数据放到同一个queue，然后对于n个线程，分别消费一个内存queue；

- 消息延时：

  1. 先修复消费者的问题，确保恢复消费速度，然后将现有消费者都停掉；
  2. 临时新建多个topic，queue；
  3. 写一个**临时分发数据的消费者**程序，将积压的数据引流(均匀轮询写入)到临时queue中；
  4. 临时征用10倍机器来部署消费者，每一批消费者消费临时queue的数据，相当于临时将queue和消费者资源扩大10倍，以正常10倍的速度消费积压的数据；
  5. 恢复原来的状态；

- 消息积压导致的过期失效：手动查出来发到messagequeue补上去；

# 缓存(redis)

## 线程模型

- **单线程工作模型**
- 内部使用文件事件处理器，这个处理器是单线程的，包含4个部分：
  1. 多个socket；
  2. IO多路复用程序；
  3. 文件事件分派器；
  4. 事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)；
- 为什么单线程模型效率也这么高？
  1. **纯内存**操作；
  2. 核心是基于**IO多路复用**机制；
  3. **C语言**实现，一般来说，C语言实现的程序“距离”操作系统更近，执行速度相对更快；
  4. 单线程避免了多线程**频繁上下文切换**的问题，预防了多线程可能产生的**竞争**问题；
- Redis6.0引入多线程：因为读写网络的Read/Write系统调用在Redis执行期间占用了大部分CPU时间，如果把**网络读写做成多线程的方式**对性能会有很大的提升；**Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。**之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。
- Redis 选择使**用单线程模型处理客户端的请求**主要还是因为 **CPU 不是 Redis 服务器的瓶颈**，所以使用多线程模型带来的性能提升并**不能抵消**它带来的开发成本和维护成本，**系统的性能瓶颈也主要在网络 I/O 操作上；**而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过**多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间**，提高执行的效率。

## 常见数据类型

1. `Strings`：普通set、get操作，做简单的KV缓存(底层实现)

   * 是一种动态字符串，类似`ArrayList`

   ```bash
   set college szu
   ```

2. `Hashes`：这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是**这个对象没嵌套其他的对象**）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 hash 里的**某个字段**。

   * 相当于 Java 中的 **HashMap**，内部实现也差不多类似，都是通过 **"数组 + 链表"** 的链地址法来解决部分 **哈希冲突**；
   * **内部包含两个 hashtable**，通常情况下只有一个 hashtable 是有值的，但是在字典扩容缩容时，需要分配新的 hashtable，然后进行 **渐进式搬迁** ；
   * 扩容是比较耗时间的，需要重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新的数组下面，这是一个 O(n) 级别的操作，作为单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 **渐进式 rehash** 小步搬迁

   ```bash
   x hset person name bingohset person age 20hset person id 1hget person name​person = {    "name": "bingo",    "age": 20,	    "id": 1}bash
   ```

3. `Lists`：有序列表

   * 相当于 Java 语言中的 **LinkedList**，可以是双链表，也可以是带头尾节点的双链表；注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)；

     ![Redis listNode结构](assets\Redis listNode结构.png)

     ![Redis listNode结构](assets\Redis list结构.jpg)

   * 通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西；

   * 可以通过 `lrange `命令，读取某个闭区间内的元素，可以基于 list 实现分页查询；基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。

   ```bash
   # 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。
   lrange mylist 0 -1
   ```

   - 简单的消息队列，从 list 头进去，从 list 尾巴那里出来。

   ```bash
   lpush mylist 1
   lpush mylist 2
   lpush mylist 3 4 5
   
   # 1
   rpop mylist
   ```

4. `Sets`：无序集合，自动去重。

   * 相当于`HashSet`；

   - 对一些数据进行**快速的全局去重**，你当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 Redis 进行全局的 set 去重。
   - 可以基于 set 玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友。

   ```bash
   #-------操作一个set-------
   # 添加元素
   sadd mySet 1
   
   # 查看全部元素
   smembers mySet
   
   # 判断是否包含某个值
   sismember mySet 3
   
   # 删除某个/些元素
   srem mySet 1
   srem mySet 2 4
   
   # 查看元素个数
   scard mySet
   
   # 随机删除一个元素
   spop mySet
   
   #-------操作多个set-------
   # 将一个set的元素移动到另外一个set
   smove yourSet mySet 2
   
   # 求两set的交集
   sinter yourSet mySet
   
   # 求两set的并集
   sunion yourSet mySet
   
   # 求在yourSet中而不在mySet中的元素
   sdiff yourSet mySet
   ```

   

5. `Sorted Sets`：排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。

   * 类似于 Java 中 **SortedSet** 和 **HashMap** 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。
   * 它的内部实现用的是一种叫做 **「[跳跃表](https://mp.weixin.qq.com/s/NOsXdrMrWwq4NTm180a6vw)」** 的数据结构，是一种多层链表结构，插入节点的时候会随机出一个层数，时间复杂度为`O(logN)`；

   ![跳跃表](assets\跳跃表.png)

   ```bash
   zadd board 85 zhangsan
   zadd board 72 lisi
   zadd board 96 wangwu
   zadd board 63 zhaoliu
   
   # 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）
   zrevrange board 0 3
   
   # 获取某用户的排名
   zrank board zhaoliu
   ```

   

6. `Bitmaps`

7. `HyperLogLogs`

8. `Streams`

## 过期策略

- 常见问题

  1. 往 Redis 写入的数据怎么没了？

     **用内存当缓存，但是内存有限**，Redis空间自然也有限，超过最大空间就必须舍弃一些数据，比如舍弃不常用的数据。

  2. 数据明明过期了，怎么还占用着内存？

     这是由 Redis 的过期策略来决定。

- 过期策略：定期删除+惰性删除

  - 定期删除：Redis 默认是每隔 100ms 就**随机抽取**一些设置了过期时间的 key，检查其是否过期，如果过期就删除。这可能会出现过期的key没被删除掉，需要**惰性删除**；
  - 惰性删除：在你**获取**某个 key 的时候，Redis 会**检查**一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。
  - 经过上面两种删除策略仍可能漏掉过期的key，长期下去key会大量堆积，耗尽内存，此时还有内存淘汰机制；

- 内存淘汰机制

  1. **allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）；
  2. volatile-lru：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，移除最近最少使用的 key（这个一般不太合适）；
  3. volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key；
  4. volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。

## 高并发、高可用

- redis基于哨兵机制的主从架构：**单主用来写入数据，多从用来查询数据**；
- redis集群：实现高并发的同时，**容纳大量数据**；

### redis[主从架构](https://adjava.netlify.app/#/./docs/high-concurrency/redis-master-slave)

一主多从+哨兵机制

#### Redis replication 的核心机制

- Redis 采用**异步方式**复制数据到 slave 节点，slave node 会**周期性地确认**自己每次复制的数据量；

- 一个 master node 是可以配置多个 slave node，slave node 也可以连接其他的 slave node；

- slave node 做复制的时候，**不会 block** master node 的正常工作；

- slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是**复制完成**的时候，需要**删除旧**数据集，**加载新**数据集，这个时候就会**暂停对外服务**了；

- 注意，如果采用了主从架构，那么建议必须**开启** master node 的[**持久化**](https://adjava.netlify.app/#/docs/high-concurrency/redis-persistence)，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。

  ​         slave node 可以**自动接管** master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。

#### Redis 主从复制的核心原理

1. 启动一个slave node的时候，它会发送一个`PSYNC`命令给master node；
2. 如果这是 slave node **初次连接**到 master node，那么会触发一次 `full resynchronization` **全量复制**，slave 会先**写入本地磁盘，然后再从本地磁盘加载到内存**中；slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。
3. 主从复制的**断点续传**：master node 会在内存中维护一个 **backlog**，master 和 slave 都会保存一个 replica offset 还有一个 **master run id**，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master **从上次 replica offset 开始继续复制**，如果没**有找到对应的 offset**，那么就会执行一次 **`resynchronization` 。**
4. 过期key处理：slave 不会过期 key，**只会等待 master 过期 key**。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave；

#### 全量复制

- master 执行 bgsave ，在本地生成一份 rdb 快照文件。

- master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)

- master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。

- 如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。

  ```bash
  client-output-buffer-limit slave 256MB 64MB 60
  ```

- slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时**基于旧的数据版本**对外提供服务。

- 如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。

#### 增量复制

- 如果**全量复制过程中**，master-slave **网络连接断掉**，那么 slave 重新连接 master 时，会触发增量复制。
- master 直接从自己的 **backlog** 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。
- master 就是根据 slave 发送的 psync 中的 **offset** 来从 backlog 中获取数据的。

#### 其他

- master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat；
- master 每次接收到写命令之后，先在内部写入数据，然后**异步**发送给 slave node；
- 如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。Redis 的高可用架构，叫做 `failover` **故障转移**，也可以叫做主备切换。
  - master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用。

### Redis持久化

持久化主要是做**灾难恢复、数据恢复**，也可以归类到高可用的一个环节中去，比如你 Redis 整个挂了，然后 Redis 就不可用了，你要做的事情就是让 Redis 变得可用，尽快变得可用。

大量的请求过来，缓存全部无法命中，在 Redis 里根本找不到数据，这个时候就死定了，出现**缓存雪崩**问题。所有请求没有在 Redis 命中，就会去 mysql 数据库这种数据源头中去找，一下子 mysql 承接高并发，然后就挂了

#### RDB机制

- 对 Redis 中的数据执行**周期性**的持久化。
- 优点：
  - RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 Redis 的数据，这种多个数据文件的方式，**非常适合做冷备**，可以将这种完整的数据文件发送到一些远程的安全存储上去；
  - 相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 Redis 进程，更加快速；
  - RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis **保持高性能**；
- 缺点：
  - RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟的数据；
  - RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒；

#### AOF 机制

- 对每条写入命令作为日志，以 `append-only` 的模式写入一个日志文件中，在 Redis 重启的时候，可以通过**回放** AOF 日志中的写入指令来重新构建整个数据集。
- 如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 **AOF** 来重新构建数据，因为 AOF 中的**数据更加完整**。
- 优点：
  - 一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 `fsync` 操作，最多丢失 1 秒钟的数据；
  - AOF 日志文件以 `append-only` 模式写入，所以**没有任何磁盘寻址的开销**，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复；
  - AOF 日志文件的命令通过**可读较强**的方式进行记录，这个特性非常**适合做灾难性的误删除的紧急恢复**。
- 缺点：
  - AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒 `fsync` 一次日志文件；
  - 通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；

#### 两种方式的选择

- 不要仅仅使用 RDB，因为那样会导致你丢失很多数据；
- 也不要仅仅使用 AOF，因为那样有两个问题：第一，你通过 AOF 做冷备，没有 RDB 做冷备来的恢复速度更快；第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug；
- Redis 支持**同时开启开启两种持久化方式**，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 **AOF 来保证数据不丢失，作为数据恢复的第一选择**; **用 RDB 来做不同程度的冷备**，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行**快速的数据恢复**。

### Redis哨兵机制

#### 功能

- 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。
- 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

## 核心知识

- 哨兵**至少需要 3 个实例**，来保证自己的健壮性。
  - 如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1，但是故障转移不会执行；
  - 3 个哨兵的 majority 是 2
- 哨兵 + Redis 主从的部署架构，是**不保证数据零丢失**的，只能保证 Redis 集群的高可用性。
- 对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。

#### 哨兵主备切换的数据丢失问题

```bash
min-slaves-to-write 1
min-slaves-max-lag 10
## 表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。
```

1. 异步复制导致的数据丢失：master->slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了；

   - 解决方案：有了 `min-slaves-max-lag` 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为**可能 master 宕机后损失的数据太多了**，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。

2. 脑裂导致的数据丢失：某个 master 所在机器突然**脱离了正常的网络**，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会**认为** master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的**脑裂**；

   此时虽然某个 slave 被切换成了 master，但是可能 client **还没来得及切换**到新的 master，还继续向旧 master 写数据。因此**旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去**，自己的数据会**清空**，重新从新的 master 复制数据。而**新的 master 并没有后来 client 写入的数据**，因此，这部分数据也就丢失了。

   - 解决方案：如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果**不能继续给指定数量**的 slave 发送数据，而且 slave **超过** 10 秒没有给自己 ack 消息，那么就直接**拒绝**客户端的写请求。因此在脑裂场景下，**最多就丢失 10 秒的数据**。

#### slave -> master选举算法

如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：

- 跟 master 断开连接的时长
- slave 优先级
- 复制 offset
- run id

如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。

```
(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_stateCopy to clipboardErrorCopied
```

接下来会对 slave 进行排序：

- 按照 slave 优先级进行排序，**slave priority 越低，优先级就越高**。
- 如果 slave priority 相同，那么看 replica offse**t，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高**。
- 如果上面两个条件都相同，那么**选择一个 run id 比较小**的那个 slave。



## 常见问题

1. 数据不一致：
2. 缓存雪崩、缓存穿透、缓存击穿：
3. 缓存并发竞争：

### 保证缓存与数据库双写一致性

- 最初级的缓存不一致问题：先**更新数据库，再删除缓存**。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。
  - 解决方案：
    - **先删除缓存，再更新数据库**。如果删除缓存失败，就不会更新数据库；如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的**旧数据**，然后更新到缓存中；

### 缓存雪崩

- 缓存意外宕机导致，缓存挂掉，大量请求落在数据库上；
- 解决方案：
  - 事前：Redis高可用，主从+哨兵，避免全盘崩溃；
  - 事中：本地缓存+hystrix限流&降级，避免mysql被打死；
  - 事后：Redis持久化，一旦重启，自动从磁盘上加载数据，快速回复缓存数据；

### 缓存穿透

- 比如是恶意攻击，发出大量在缓存查不到值的请求，然后就直接查询数据库，直接穿透缓存将数据库打死；
- 解决方案：
  - 每次系统 A 从数据库中只要没查到，就**写一个空值到缓存**里去，比如 `set -999 UNKNOWN` 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据；

### 缓存击穿

- 某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 **key 在失效的瞬间**，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞;
- 解决方案（**缓存的数据更新时间**的角度）：
  - 基本不更新：将热点数据设置为永不过期；
  - 更新不频繁，且缓存刷新的流程耗时较少：采用**互斥锁**的方式保证仅少量的请求去请求数据库并重新构建缓存，其余请求在锁释放后可以访问到新缓存；
  - 更新频繁，或者缓存刷新的流程耗时较长：利用**定时线程**在缓存过期前**主动**地重新构建缓存或者**延后**缓存的过期时间，以保证所有的请求能一直访问到对应的缓存；

### Redis并发竞争问题

- Redis自带CAS类的**乐观锁**方案：要写入缓存的数据，都是从mysql里查出来的，在写入mysql中必须保存一个**时间戳**，从mysql查出来的时候，时间戳也查出来。每次写入缓存之前，先判断当前的value的时间戳是否比缓存里的要新，如果是，就可以写入，否则就不能去覆盖新的数据。

## 本地缓存

Google Guava

Ehcache

Caxxxxx

# Java容器



# JVM

## JVM内存结构

### 程序计数器

- 作用：
  1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制；
  2. 在多线程下，记录的是当前线程的执行位置，线程切换回来就知道从哪开始继续执行；
- 特点：
  1. 内存空间小
  2. 线程私有
  3. 生命周期与线程挂钩
  4. 唯一不会出现OOM的内存区域

### java虚拟机栈

描述java方法运行过程的内存模型

虚拟机栈为每一个即将运行的java方法创建一个栈帧，里面存放：局部变量表(基本类型、对象的引用和`returnAddress`)、操作数栈、动态链接、方法出口信息等；

- 出栈压栈的过程：
  1. 方法创建，局部变量存入栈帧的局部变量表中；
  2. 栈顶栈帧为正在执行的活动栈，调用另一个方法，创新新的栈帧压入栈顶；
  3. 方法结束(return或者抛出异常)，栈帧移除，返回值(如果有)变为栈顶栈帧中操作数栈的一个操作数
- 特点：
  1. **局部变量表**随着栈帧的创建而创建，它的**大小在编译时确定**，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。
  2. Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError
     - StackOverFlowError 若 Java 虚拟机栈的大小**不允许动态扩展**，那么当**线程请求栈的深度超过当前 Java 虚拟机栈的最大深度**时，抛出 StackOverFlowError 异常；
     - OutOfMemoryError 若**允许动态扩展**，那么当线程请求栈时**内存用完了，无法再动态扩展**时，抛出 OutOfMemoryError 异常；
  3. Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁；

### 本地方法栈

本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

### 堆

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。

- 特点
  - **线程共享**，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
  - 在虚拟机**启动时创建**。
  - 是垃圾回收的主要场所。
  - 进一步可分为：**新生代**(Eden区 From Survior To Survivor)、**老年代**。

### 方法区

方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

### 元数据区

JDK1.7前叫永久代，都是方法区的实现方式，因为永久代受JVM设置固定大小的限制，无法进行调整，而**元空间直接使用内存**，受本机可用内存的限制，内存溢出的情况更少；



## 四种引用类型

### 1. 强引用

不会被回收；

### 2. 软引用

内存足够，不会回收；内存不足，才去回收；

### 3. 弱引用

垃圾回收器一旦发现只具有弱引用的对象，不管内存空间是否足够，都会回收掉；

### 4. 虚引用

形同虚设，一个对象仅持有虚引用，就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

### 注意

在程序设计中一般很少使用弱引用与虚引用，使用**软引用的情况较多**，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

## JVM内存分配与回收

![JVM堆内存分配](D:/JavaLib/assets/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.png)

- 大部分情况，对象都会首先在 **Eden 区**域分配，**在一次新生代垃圾回收后**，如果对象还存活，则会进入 **s0 或者 s1**，并且对象的**年龄还会加 1**(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（**默认为 15 岁**），就会被晋升到**老年代**中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。当**累积的某个年龄大小超过了survivor区的一半时**，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。

![堆内存分配策略](D:/JavaLib/assets/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png)



- 经过一次GC后，Eden区和"From"区已经被清空。这个时候，**"From"和"To"会交换他们的角色**，也就是新的"To"就是上次GC前的“From”，新的"From"就是上次GC前的"To"。不管怎样，都会**保证名为To的Survivor区域是空的**。Minor GC会一直重复这样的过程，直到“To”区被填满，**"To"区被填满之后，会将所有对象移动到老年代中**。

* 大多数情况下，对象在新生代中 eden 区分配。**当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC；**

* 大对象直接进入老年代：为了避免为大对象分配内存时由于**分配担保**机制带来的复制而降低效率;

## 垃圾回收

程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。这几个区域的内存分配和回收都具有**确定性**，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而对于 Java 堆和方法区，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的**分配和回收都是动态的**，垃圾收集器所关注的正是这部分内存。

- 判定对象是否存活：若一个对象**不被任何对象或变量引用**，那么它就是无效对象，需要被回收。
- 在可达性分析法中不可达的对象，也**并非是“非死不可”**的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历**两次标记**过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象**没有覆盖 finalize 方法**，或 finalize 方法**已经被虚拟机调用过**时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被**放在一个队列中进行第二次标记**，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

* **废弃常量**：比如，在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量；
* **无用的类**：3个条件：
  1. 该类所有的实例都已经被回收，也就是 Java 堆中**不存在该类的任何实例**；
  2. 加载该类的 **ClassLoader** 已经被回收；
  3. 该类对应的 **java.lang.Class 对象**没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；



### 策略

- **引用计数法**：在对象头维护着一个 **counter 计数器**，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。
  - 虽然效率高，但很难解决对象之间循环引用的问题；
- **可达性分析法**：所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。
  - GC Roots指：
    1. Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
    2. 本地方法栈中引用的对象
    3. 方法区中常量引用的对象
    4. 方法区中类静态属性引用的对象
  - GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。

### 回收算法

#### 1. 标记-清除算法

- 标记的过程：遍历所有的 `GC Roots`，然后将所有 `GC Roots` 可达的对象**标记为存活的对象**。
- 清除的过程：遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。
- 缺陷：
  - 效率：标记和清除两个过程的效率都不高；
  - 空间：标记清除之后会**产生大量不连续的内存碎片**，碎片太多可能导致以后需要分配较大对象时，**无法找到足够的连续内存**而不得不提前触发另一次垃圾收集动作。

#### 2. 复制算法（新生代）

为了解决标记-清除算法的效率问题，**将内存等分两块，每次只使用一块**，当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。

- 优点：不会有内存碎片的问题。
- 缺点：内存缩小为原来的一半，浪费空间。

为了**解决空间利用率**问题，可以将内存分为三块： **Eden、From Survivor、To Survivor**，比例是 **8:1:1**，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。

但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。

- **分配担保**：为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 **Minor GC 过后依然有超过 10% 的对象存活**，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。

#### 3. 标记-整理算法(老年代)

- 标记的过程：它的第一个阶段与**标记-清除算法**是一模一样的，均是遍历 `GC Roots`，然后将存活的对象标记。
- 移动所有**存活的对象**，且按照内存地址次序依次**排列**，**然后将排序号末端内存地址以后的内存全部回收**。因此，第二阶段才称为整理阶段。

#### 4. 分代收集算法

根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。

- 新生代：复制算法
- 老年代：标记-清除算法、标记-整理算法

## 垃圾收集器

### 1. Serial收集器

* 特点：单线程，简单而高效；
* 回收算法：新生代采用复制算法，老年代采用标记整理算法；

### 2. ParNew收集器

* `Serial`的多线程版本；

### 3. Parallel Scavenge+Parallel Old收集器

* 几乎和`ParNew`一样，但是其关注点是吞吐量（高效率的利用CPU），`CMS`关注点在用户线程的停顿时间（提高用户体验）；

### 4. CMS收集器

* 第一次实现了让垃圾收集线程与用户线程基本同时工作；
* 回收算法：标记-清除算法
  1. **初始标记**：暂停所有其他线程，记录直接与root相连的对象，速度很快；
  2. **并发标记**：用户线程不会断地更新引用域，需要**跟踪记录**引用更新的地方；
  3. **重新标记**：**修正**并发标记期间因为用户线程再次产生变动的标记记录；
  4. **并发清除**：开启用户线程，同时 GC 线程开始对未标记的区域做清扫；

### 5. G1(Garbage-First)

* 面向服务器，主要针对多处理器以及大容量内存的机器
* 能够满足**GC停顿时间**的要求，还具备**高吞吐量**；
* 回收算法：标记-整理
  1. 初始标记；
  2. 并发标记；
  3. 最终标记；
  4. 筛选回收；
* G1 收集器在后台维护了一个**优先列表**，每次根据允许的收集时间，优先选择回收价值最大的区域；

## 类加载过程

* 类的生命周期

![类的生命周期](assets\类的生命周期.png)

### 加载

1. 通过**全类名**获取定义此类的**二进制字节流**
2. 将字节流所代表的**静态存储结构**转换为方法区的**运行时**数据结构
3. 在内存中**生成一个代表该类的 Class 对象**,作为方法区这些数据的访问入口

### 验证

![类的验证阶段](assets\类的验证阶段.png)

### 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，**实例变量会在对象实例化时随着对象一块分配在 Java 堆中**。
2. 这里所设置的初始值"通常情况"下是**数据类型默认的零值**（如0、0L、null、false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。
3. 静态变量在这个阶段会赋给默认值，在是初始化阶段的**类初始化时**进行赋值操作的；而静态常量在这个阶段会赋给期望值。

![基本数据类型的零值](D:\JavaLib\assets\基本数据类型的零值.png)



### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

### 初始化

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 `<clinit> ()`方法的过程。

对于初始化阶段，虚拟机严格规范了有且只有5种情况下，**必须对类进行初始化**(只有主动去使用类才会初始化类)：

1. 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 **new** 一个类，读取一个**静态**字段(未被 final 修饰)、或调用一个类的静态方法时。
   - 当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。
   - 当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
   - 当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。
   - 当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。
2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用**时如Class.forname("..."),newInstance()等等。 ，如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该**父类的初始化**。
4. 当虚拟机启动时，用户需要定义一个要执行的**主类** (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。
6. **「补充，来自issue745」** 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个**接口**的实现类发生了初始化，那该接口要在其**之前**被初始化。

### 卸载

卸载类即该类的Class对象被GC。

**卸载类需要满足3个要求:**

1. 该类的**所有的实例对象都已被GC**，也就是说堆不存在该类的实例对象；
2. 该类**没有在其他任何地方被引用；**
3. 该类的**类加载器的实例已被GC**；

所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。



## JVM调优

通常指GC调优

### GC调优原则

多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； **在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）**； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，**分析 GC 情况优化代码比优化 GC 参数要多得多**。

### GC调优目的

将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。

### GC调优策略

1. 将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。
2. 大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。`-XX:PretenureSizeThreshold` 可以设置直接进入老年代的对象大小。
3. 合理设置进入老年代对象的年龄，`-XX:MaxTenuringThreshold` 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。
4. 设置稳定的堆大小，堆大小设置有两个参数：`-Xms` 初始化堆大小，`-Xmx` 最大堆大小。
5. 注意： 如果满足下面的指标，**则一般不需要进行 GC 优化：**
   * MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。

# [Java异常](https://blog.csdn.net/qq_29229567/article/details/80773970)

## 总览

**所有的错误和异常都继承自`Throwable`类，下分`Error`和`Exception`两大子类；**

* 错误和异常的区别：错误无法被处理，异常能被程序本身捕获并处理；
* 异常`Throwable`分为两种类型：
  * 受查异常：编译器要求**必须处置**的异常。除了`RuntimeException`类及其子类以外的`Exception`子类，程序中出现这类异常，要么用**`try-catch`捕获**，要么用**`throws`子句声明抛出**，否则**编译不会通过**；
  * 非受查异常：编译器**不要求强制处置**的异常。包括运行时异常`RuntimeException`及其子类和错误`Error`。

* `Error`：是**程序无法处理**的错误，表示运行的应用程序中出现较严重的问题，大多数错误与代码编写者执行的操作无关，表示代码运行时JVM出现的问题。这些错误是**不可查**的，对于设计合理的应用程序来说，不应该试图去处理这种异常状况。
* `Exception`：是**程序本身可以处理**的异常，分为两大类：
  * 运行时异常：为`RuntimeException`类及其子类， 这些异常是**非受查异常**，一般由程序逻辑错误引起，编译器不会去检查它，也就是没有`tay-catch`和`throws`也会编译通过；
  * 非运行时异常：`RuntimeException`以外的异常，必须要被处理，否则程序不能编译通过；

## 常见异常

1. `RuntimeException`子类：

| 序号 | 异常名称                                 | 异常描述                                                     |
| :--- | :--------------------------------------- | :----------------------------------------------------------- |
| 1    | java.lang.ArrayIndexOutOfBoundsException | 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 |
| 2    | java.lang.ArithmeticException            | 算术条件异常。譬如：整数除零等。                             |
| 3    | java.lang.SecurityException              | 安全性异常                                                   |
| 4    | java.lang.IllegalArgumentException       | 非法参数异常                                                 |
| 5    | java.lang.ArrayStoreException            | 数组中包含不兼容的值抛出的异常                               |
| 6    | java.lang.NegativeArraySizeException     | 数组长度为负异常                                             |
| 7    | java.lang.NullPointerException           | 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 |

2. `IOException`

| 序号 | 异常名称              | 异常描述                           |
| :--- | :-------------------- | :--------------------------------- |
| 1    | IOException           | 操作输入流和输出流时可能出现的异常 |
| 2    | EOFException          | 文件已结束异常                     |
| 3    | FileNotFoundException | 文件未找到异常                     |

3. 其他受查异常

| 序号     | 异常名称                               | 异常描述                                                     |
| :------- | :------------------------------------- | :----------------------------------------------------------- |
| 1        | ClassCastException                     | 类型转换异常类                                               |
| 2        | ArrayStoreException                    | 数组中包含不兼容的值抛出的异常                               |
| 3        | SQLException                           | 操作数据库异常类                                             |
| 4        | NoSuchFieldException                   | 字段未找到异常                                               |
| 5        | NoSuchMethodException                  | 方法未找到抛出的异常                                         |
| 6        | NumberFormatException                  | 字符串转换为数字抛出的异常                                   |
| 7        | StringIndexOutOfBoundsException        | 字符串索引超出范围抛出的异常                                 |
| 8        | IllegalAccessException                 | 不允许访问某类异常                                           |
| 9        | InstantiationException                 | 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常 |
| ***10*** | ***java.lang.ClassNotFoundException*** | ***找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。*** |

# [Java I/O](https://snailclimb.gitee.io/javaguide/#/docs/java/BIO-NIO-AIO)

**Java中提供的IO有关的API，在文件处理的时候，其实依赖操作系统层面的IO操作实现的。**

## 分类

### 1.按操作方式分类

![IO按操作方式分类](assets\IO按操作方式分类.jpg)

### 2. 按操作对象分类

![IO按操作对象分类](assets\IO按操作对象分类.jpg)

## 1. BIO(Blocking I/O)

### 1.1 传统BIO

![BIO模型](assets\传统BIO模型.png)

* 采用BIO模型的服务端通过一个独立的`Acceptor`线程负责监听客户端的链接；
* 在`while(true)`循环中调用`accept()`等待接收客户端请求；
* 对于每一个请求来创建一个新的线程来处理；

### 1.2 伪异步IO

![伪异步IO](assets\伪异步IO.png)

* 减少BIO处理多请求产生的创建/销毁线程开销；
* 将客户端的Socket封装成一个Task，投递到后端的线程池的消息队列中进行处理；
* 可以使用线程数量固定的线程池`FixedThreadPool`或者自定义线程池；
* 底层仍是同步阻塞BIO模型，只起到**缓冲**的作用，无法从根本上解决问题；

## 2. NIO

**支持面向缓冲，基于通道的I/O操作方法，应用于高负载、高并发的应用。**

### NIO的特性与IO的区别

#### 2.1 Non-blocking IO

* NIO：单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
* IO：当一个线程调用 `read()` 或 `write()` 时，该线程**被阻塞**，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。

#### 2.2 Buffer（缓冲区）

* NIO：**面向缓冲区**。所有数据都是用**缓冲区**处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。
* IO：**面向流**。将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区。

#### 2.3 Channel（通道）

* NIO：**通过Channel进行读写**。通道是**双向**的，可读也可写，而**流**的读写是**单向**的。无论读写，**通道只能和Buffer交互**。因为 Buffer，**通道可以异步地读写**。

#### 2.4 Selector（选择器）

* NIO：为了减少线程之间的切换，提高系统效率，选择器用于使用**单个线程处理多个通道。**因此，它需要较少的线程来处理这些通道。

### 3. AIO(Asynchronous I/O)

* AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。**异步 IO 是基于事件和回调机制实现的**，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

* 虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。**除了 AIO 其他的 IO 类型都是同步的**，这一点可以从底层IO线程模型解释；

# Linux

## [Linux的5种IO模型](https://blog.csdn.net/z_ryan/article/details/80873449)

**可以把Java中的BIO、NIO和AIO理解为是Java语言对操作系统的各种IO模型的封装。**程序员在使用这些API的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。

* 一次完整的IO操作：是文件从硬盘中拷贝到用户空间(内存)中；

### 1. 阻塞IO模型

![阻塞IO模型](assets\阻塞IO模型.png)

* 进程或线程等待内核准备好数据报，如果还未准备好，就会一直等待下去，直到达到条件才执行下一步；

### 2. 非阻塞IO模型

![非阻塞IO模型](assets\非阻塞IO模型.png)

* 进程通过轮询的方式查看内核中数据报是否准备好，**在轮询的间隔内可以去执行其他操作**，下一次轮询发现数据已经准备好了，就把数据拷贝到用户空间中，增加了时间利用率；

### 3. 信号驱动IO模型

![信号驱动IO模型](assets\信号驱动IO模型.png)

* 不再多次轮询，进程预先向内核注册一个信号处理函数，然后返回执行其他操作，等内核数据准备就绪时，发送信号通知进程数据准备好，可以进行执行拷贝操作；

### 4. IO复用模型（select，poll，epoll）

 ![IO复用模型](assets\IO复用模型.png)

* 单个进程同时处理多个网络连接的IO，需要使用**两个system call** (select 和 recvfrom)，阻塞IO只调用recvfrom一个system cal；
* **基本原理**就是不再由应用程序自己监视连接，取而代之**由内核替应用程序监视文件描述符**。
* 以select为例，当用户进程调用了select，那么整个**进程会被阻塞**，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程；
* 也属于阻塞IO，只不过进程**被select函数阻塞**，而不是被IO操作阻塞；
* **适用于连接数比较大**的情况，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，否则可能不如阻塞IO效率高；

### 5. 异步IO模型

**以上都是同步的IO模型，即使是非阻塞，也只是在数据准备阶段是异步的，数据拷贝操作都是同步的。**

![异步IO模型](assets\异步IO模型.png)

* 进程包IO请求传给内核后，完全有内核去操作文件拷贝，内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。
* 用户进程发起`aio_read`操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当**内核收到`aio_read`后，会立刻返回**，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。

### 5种IO模型对比

![Linux五种IO模型对比](assets\Linux五种IO模型对比.png)

## 常用命令

- 查看系统资源使用情况：

```shell
## 整体资源使用情况
top

## 查看负载
uptime

## 查看占用cpu最高的进程
ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head

## 查看占用内存最高的进程
ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head

```

其中第一句主要是为了获取标题（USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND）。
接下来的grep -v PID是将ps aux命令得到的标题去掉，即grep不包含PID这三个字母组合的行，再将其中结果使用sort排序。
sort -rn -k +3该命令中的-rn的r表示是结果倒序排列，n为以数值大小排序，而-k +3则是针对第3列的内容进行排序，再使用head命令获取默认前10行数据。(其中的|表示管道操作)

**补充:内容解释**

- PID：进程的ID
  USER：进程所有者
  PR：进程的优先级别，越小越优先被执行
  NInice：值
  VIRT：进程占用的虚拟内存
  RES：进程占用的物理内存
  SHR：进程使用的共享内存
  S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
  %CPU：进程占用CPU的使用率
  %MEM：进程使用的物理内存和总内存的百分比
  TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
  COMMAND：进程启动命令名称

- 管道符|：实际是shell在为每一个命令创建一个进程的时候修改了打开文件列表，将上一个命令进程的标准输出设为下一个命令进程的标准输入

## [Linux性能分析工具合集](https://snailclimb.gitee.io/javaguide/#/docs/operating-system/Linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86)



## Linux进程间通信

1. **管道**（Pipe）及**有名管道**（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2. **信号**（Signal）：信号是比较复杂的通信方式，**用于通知接受进程有某种事件发生**，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
3. **报文**（Message）**队列**（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了**信号承载信息量少**，**管道只能承载无格式字节流以及缓冲区大小受限**等缺点。
4. **共享内存**：使得多**个进程可以访问同一块内存空间**，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如**信号量结合使用，来达到进程间的同步及互斥**。
5. **信号量**（semaphore）：主要**作为进程间以及同一进程不同线程之间的同步手段**。
6. **套接字**（Socket）：更为一般的进程间通信机制，**可用于不同机器之间的进程间通信**。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。



# 操作系统

## 进程和线程

### 进程

* 是程序在执行过程中分配和管理资源的基本单位；
* 特征：
  * 动态性：进程是**程序的一次执行过程**，是临时的，有生命期的，是动态产生，动态消亡的；
  * 并发性：任何进程都可以同其他进行一起并发执行；
  * 独立性：进程是系统进行资源分配和调度的一个独立单位；
  * 结构性：进程由**程序，数据和进程控制块**三部分组成；

### 线程

* 是CPU调度和分派的基本单位；
* 可与同属一个进程的其他的线程**共享**进程所拥有的全部资源；

### 区别

1. 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位；
2. 开销：每个进程都有独立的代码和数据空间（程序上下文），**进程之间切换开销大**；每个线程都有自己独立的运行栈和程序计数器（PC），线程执行开销小，但不利于资源的管理和保护；
3. 内存分配：系统为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（**线程所使用的资源来自其所属进程的资源**），线程组之间只能共享同一个进程的资源；
4. 包含关系：线程是进程的一部分，所以**线程也被称为轻权进程或者轻量级进程**；

# 计算机网络

TCP三次握手和四次挥手

cookie和session

# 其他

### 并发操作下扣减库存避免超卖

1. 使用`synchronized`或者`Lock`加锁同步；

   * 缺点：效率不高；

2. 使用`select for update`，这是数据库行锁，锁定更新行的操作；

   * 行锁并不是直接锁记录，而是锁索引，如果一条sql语句用到了主键索引，mysql会锁住主键索引；如果语句**操作了非主键索引**，就会**先锁住非主键索引**，**再锁定主键索引**。

   * 缺点：容易造成死锁：(id为主键索引，user_id，item_id为非主键索引)

     * `update user_item set status=1 where user_id=? and item_id=?`；

       1. 由于用到了非主键索引，首先需要获取idx_1上的行级锁

       2. 紧接着根据主键进行更新，所以需要获取主键上的行级锁；

       3. 更新完毕后，提交，并释放所有锁。

     * `update user_item .....where id=? and user_id=?`这条语句插入到上面步骤的1和2之间，它会先获取主键上的行级锁，再等待获取非主键的行级锁，这样两个都要等待对方持有的锁释放，就产生了死锁；

3. `Redis`分布式锁：更细粒度的控制，多台机器上多个进程对一个数据进行操作的互斥；

   1. 用`setnx`锁住，如果可以设置（productId， 超时时间），就返回`true`，也就是获取到锁；
   2. 根据先通过`get(key)`获取的超时时间判断锁是否过期，如果过期就尝试去获取锁：通过`getAndSet(key,value)`先获取上个锁的时间，再设置自己的时间进去，并判断先后两次获取的时间是否相等，如果不相等，就意味着，已经有其他线程`getAndSet`并且获取到了锁。