# MySQL

## 数据库设计

### 1. [分库分表](https://blog.csdn.net/weixin_44062339/article/details/100491744)

#### 垂直分表

- 定义：可以把一个宽表的字段按访问频次、是否是**大字段**的原则拆分为多个表，每个表存储其中一部分字段；
- 场景：系统绝对**并发量并没有上来，表的记录并不多**，但是**字段多**，并且**热点数据和非热点数据在一起**，**单行数据所需的存储空间较大。以至于数据库缓存的数据行减少**，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。
  - 为什么大字段IO效率低：
    1. 由于数据量本身大，需要更长的读取时间；
    2. 跨页，**页是数据库存储单位**，很多查找及定位操作都是以页为单位，单页内的数据行越多数据库整体性能越好，而大字段占用空间大，**单页内存储行数少，因此IO效率较低**。
    3. **数据库以行为单位将数据加载到内存中**，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，**命中率更高，减少了磁盘IO**，从而提升了数据库性能。
- 结果：
  - 每个**表**的**结构**都不一样；
  - 每个**表**的**数据**也不一样，一般来说，每个表的**字段**至少有一列交集，一般是主键，用于**关联数据**；
  - 所有**表**的**并集**是全量数据；
- 提升：使业务清晰，提升部分性能；
- 缺陷：尽量从业务角度**避免联查**，否则性能方面将得不偿失；

#### 垂直分库

- 定义：按照业务将表进行分类，分布到不同的数据库上，每个库可以放在不同的服务器上，它的核心理念是**专库专用**；
- 场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块；
- 结果：
  - 每个**库**的**结构**都不一样；
  - 每个**库**的**数据**也不一样，没有交集；
  - 所有**库**的**并集**是全量数据；
- 提升：多个服务器共同负载，大大提升性能，还能提高整体架构的业务清晰度，不同的业务库可根据自身情况定制优化方案；
- 缺陷：需要解决跨库带来的复杂问题，**避免跨库联查**；

#### 水平分库

- 定义：把同一个表的数据按一定规则拆分到不同的数据库中，每个库可以放在不同的服务器上；
- 场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库；
- 结果：
  - 每个**库**的**结构**都一样；
  - 每个**库**的**数据**都不一样，没有交集；
  - 所有**库**的**并集**是全量数据；
- 提升：解决了单库大量的数据对服务器的压力；
- 缺陷：需要解决跨库带来的复杂问题，以及数据路由问题

#### 水平分表

- 定义：在同一个数据库内，把同一个表的数据按一定规则拆到多个表中；
- 场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈；
- 结果：
  - 每个**表**的**结构**都一样；
  - 每个**表**的**数据**都不一样，没有交集；
  - 所有**表**的**并集**是全量数据；
- 提升：性能小幅提升，仅仅是对水平分库的一个补充优化；
- 缺陷：

#### 带来的问题以及解决方案

##### 1. 主键ID

1. UUID：本地生成，但是太长，作为主键性能很差，而且不具备有序性；

2. 系统当前时间+用户ID后四位+随机数；

3. `twitter`的`snowflake`算法

   - 核心思想：使用一个 64 bit 的 long 型的**数字**作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的；

   - ##### 格式

     ![img](https://img2020.cnblogs.com/blog/813155/202005/813155-20200511162334239-459232117.png)

     - 1bit - 首位无效符

     - 41bit - 时间戳（毫秒级）

       - 41位可以表示2^41^ -1个数字；
       - 2^41^ -1毫秒，换算成年就是表示 69 年的时间

     - 10bit - 工作机器id

       - 5bit - datacenterId机房id
       - 5bit - workerId机器 id

     - 12bit - 序列号

       序列号，用来记录同一个datacenterId中某一个机器上同毫秒内产生的不同id；

   - ##### 优点

     - 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
     - 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
     - 可以根据自身业务特性分配bit位，非常灵活。

     ##### 缺点

     - 雪花算法在单机系统上ID是递增的，但是在分布式系统多节点的情况下，所有节点的时钟并不能保证不完全同步，所以有可能会出现不是全局递增的情况。如果系统时间被回调，或者改变，可能会造成id冲突或者重复。

##### 2. 跨库Join的几种解决思路

1. 全局表
2. 字段冗余

## MyISAM和Innodb的区别

1. **是否支持行级锁** : MyISAM 只有**表级锁(**table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,**默认为行级锁**。
2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是**性能**，**每次查询具有原子性**,其执行速度比InnoDB类型更快，但是**不提供事务支持**。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
   - InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！；
3. **是否支持外键：** MyISAM不支持，而InnoDB支持。
4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;**MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作**;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

## 索引

## 事务



## MVCC

MVCC (Multiversion Concurrency Control)，即**多版本并发控制技术**,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把**数据库的行锁与行的多个版本结合起来**，只需要很小的开销,就可以实现**非锁定读**，从而大大提高数据库系统的并发性能。

- MVCC特点：

  - **每行**数据都存在一个版本，**每次数据更新时都更新该版本**
  - **修改时复制**出当前版本随意修改，各个事务之间无干扰
  - **保存时比较**版本号，如果成功（commit），则覆盖原记录；失败则放弃复制（rollback）

  每行都有版本号，保存时根据版本号决定是否成功，听起来含有**乐观锁**的味道；

  

## 连接池

- 如果不用数据库连接池，一次sql查询请求会经过以下步骤：
  1. 和`MySQL server`建立`TCP`连接：
     - 三次握手；
  2. `MySQL`权限认证：
     1. `Server`向`Client`发送密钥；
     2. `Client`使用密钥加密用户名、密码等信息，将加密后的报文发送给`Server`；
     3. `Server`根据`Client`请求包，验证是否是合法用户，然后给`Client`发送认证结果；
  3. `Client`发送`SQL`语句；
  4. `Server`返回语句执行结果；
  5. `MySQL`关闭；
  6. `TCP`连接断开；
     - 四次挥手；
- 不使用连接池的话，为了执行一条 SQL，会花很多时间在**安全认证、网络IO**上，如果使用连接池，执行一条 SQL **就省去了建立连接和断开连接所需的额外开销**。
- 用`connection.close()`不会直接关掉连接，而是被连接池回收，实现复用；