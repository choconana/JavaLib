# Java内存模型

* 分清JVM内存结构、Java内存模型、Java对象模型

## 底层原理

### 从Java代码到CPU指令

![1586931195388](课件\java_concurrency_core\课程资料\从Java代码到CPU指令.png)



1. 最开始，我们编写的Java代码，是*.java文件；
2. 在编译（javac命令）后，从刚才的.java文件会变出一个新的Java字节码文件（.class）；
3. JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令；
4. 机器指令可以直接在CPU上运行，也就是最终的程序执行。

* **而不同的JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别**；所以我们在java代码层写的各种Lock，其实最后依赖的是JVM的具体实现（不同版本会有不同实现）和CPU的指令，才能帮我们达到线程安全的效果。
* 由于最终效果依赖处理器，不同处理器结果不一样，这样无法保证并发安全，所以**需要一个标准，让多线程运行的结果可预期**，这个标准就是JMM。

## 三兄弟

### JVM内存结构

* 和Java虚拟机的**运行时区域**有关

![1586931840821](课件\java_concurrency_core\课程资料\JVM内存结构.png)

#### 堆(heap)

* 是整个运行区域中最大的一块，占用的内存最多
* 主要是通过new等指令创建的实例对象
* 优势：在运行时动态分配

#### 虚拟机栈(Java栈)

* 保存基本数据类型，以及对象的**引用**(对象**本身**保存在堆中)
* 编译的时候就确定了大小，运行时也不会改变

#### 方法区(method)

* 主要存储已经加载的静态变量、类信息以及常量信息，还包括**永久引用**(如：被static修饰的普通引用)

#### 本地方法栈

* 主要保存于本地方法(native修饰的方法)相关的

#### 程序计数器

* 内存占比最小
* 主要保存当前线程所执行到的字节码的行号数，下一条需要执行的指令、分支、循环等异常处理



### Java内存模型

* 和Java的**并发编程**有关

### Java对象模型

* 和Java对象在虚拟机中的**表现形式**有关

![1586932560552](课件\java_concurrency_core\课程资料\Java对象模型.png)

* Java对象自身的存储模型(存储结构)
* JVM会个这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。
* 使用new创建一个对象时，JVM会在栈中给对象赋值，在堆中创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。

## Java内存模型(JMM)

### 为什么需要JMM

* C语言不存在内存模型的概念
  * 这样的语言很多行为是依赖于处理器本身的内存一致性模型，不同处理器结果不一样，从而无法保证并发安全。
* 需要一个标准，让多线程运行的结果**可预期**

### JMM是什么？

#### JMM是规范

* 是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，**更方便地开发多线程程序**。
* 如果没有这样的一个JMM来规范，那么很可能经过了不同JVM的不同规则的**重排序**之后，导致不同的虚拟机上运行的结果不一样。

#### JMM是工具类和关键字的原理

* volatile、synchronized、Lock等的原理都是JMM
* 如果没有JMM，那就需要我们自己指定什么时候用内存栅栏，那时相当麻烦的。而有了JMM，我们只需要用同步工具和关键字就可以开发并发程序。



### JMM三个重要性质

#### 重排序(OutOfOrderExecution)

* 重排序的代码案例、什么是重排序
* 重排序的好处：提高处理速度
* 3种情况：编译器优化、CPU指令重排、内存的“重排序”

##### 重排序分析

~~~java
 		Thread one = new Thread(new Runnable() {
            @Override
            public void run() {
                a = 1;
                x = b;
            }
        });
        Thread two = new Thread(new Runnable() {
            @Override
            public void run() {
                b = 1;
                y = a;
            }
        });
~~~

* 这4行代码的执行顺序决定了最终x和y的结果，一共有3中情况：

1. 线程1先运行完毕：

   `a=1;x=b(0);b=1;y=a(1)`，最终结果是x=0, y=1；

2. 线程2先运行完毕：

   `b=1;y=a(0);a=1;x=b(1)`，最终结果是x=1, y=0;

3. 两个线程交替执行：

   `b=1;a=1;x=b(1);y=a(1)`，最终结果是x=1, y=1;

4. 发生**重排序**：

   `y=a(0);a=1;x=b(0);b=1`，最终结果是x=0, y=0；

##### 什么是重排序？

* 在线程1内部的两行代码的**实际执行顺序**和代码在**Java文件中的顺序**不一致，代码指令并不是严格按照代码语句顺序执行的，它们的顺序被改变了。

##### 重排序的好处

* 对比重排序前后的指令优化

![1586936824830](课件\java_concurrency_core\课程资料\指令重排序.png)



##### 重排序的3种情况

1. 编译器优化：编译器(包括JVM，JIT编译器等)出于优化目的，在编译过程中进行一定程度的重排，导致生成的机器指令和之前的字节码的顺序不一致。
2. CPU指令重排：通过乱序执行的技术，来提高执行效率。
3. **内存的“重排序”**：**内存系统不存在重排序**，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在JMM里表现为主存和本地内存，由于**主存和本地内存的不一致**，会使得程序表现出乱序的行为。由此引出**可见性问题**。

#### 可见性

##### 什么是可见性问题？

* 写线程的赋值操作的结果还未写入主存中的时候，读线程就向主存中取数据

![1586939589796](课件\java_concurrency_core\课程资料\可见性问题.png)

* 用**volatile**解决问题

![1586939996241](课件\java_concurrency_core\课程资料\volatile解决可见性问题1.png)

![1586940041840](课件\java_concurrency_core\课程资料\volatile解决可见性问题2.png)

##### 为什么会有可见性问题

![1586940251832](课件\java_concurrency_core\课程资料\可见性原因.png)

* CPU有多级缓存，导致读的数据过期
  * 高速缓存的容量比主内存小，但是速度仅次于寄存器，所以在CPU和主内存之间就多了cache层
  * 线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由**多缓存**引起的
  * 如果所有核心都只用一个缓存，那么也就不存在内存可见性问题了
  * 每个核心都会将自己需要的数据读到**独占缓存**中，数据修改后也是写入到缓存中，然后**等待刷入到主存**中。所以会导致有些核心读取的值是过期的值。

##### JMM的抽象：主内存和本地内存

* Java 作为高级语言，屏蔽了CPU多层缓存这些底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。
* 这里说的本地内存并不是真的是一块给每个线程分配的内存，而是 JMM 的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。

![img](课件\java_concurrency_core\课程资料\JMM内存抽象.jpg)

![1586941315342](课件\java_concurrency_core\课程资料\JMM内存抽象1.png)

##### JMM有以下规定

1. **所有的变量都存储在主内存**中，同时每个线程也有自己独立的工作内存，**工作内存中的变量**是主内存中的**拷贝**；
2. **线程不能直接读写主内存中的变量**，而是只能操作自己工作内存中的变量，然后再同步到主内存中；
3. 主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要**通信**，必须借助**主内存中转**来完成。

##### 可见性问题的原因

* 所以的**共享变量存在于主内存**中，每个线程有自己的本地内存，而且线程读写共享数据也是**通过本地内存借助主内存交换**的，所以才导致了**可见性问题**。

##### Happens-Before原则

###### 什么是happens-before

* 用来解决可见性问题。在时间上，动作A发生在动作B之前，B保证能看见A

###### 什么不是happens-before

* 两个线程没有相互配合的机制，所以代码X和Y的执行结果并不能保证总被对方看到，这就不具备happens-before.

##### Happens-Before规则

1. 单线程规则：不影响重排序，后面总能看到前面

![1586942716587](课件\java_concurrency_core\课程资料\happens-before规则之单线程规则.png)

2. **锁操作**(synchronized和Lock)

![1586942999394](课件\java_concurrency_core\课程资料\happens-before规则之锁操作.png)

3. **volatile变量**
   * **近朱者赤**：给x加了volatile，不仅x被影响，也可以实现**轻量级同步**

![1586943231201](课件\java_concurrency_core\课程资料\happens-before规则之volatile变量.png)

4. 线程启动

![1586943442809](课件\java_concurrency_core\课程资料\happens-before规则之线程启动.png)

5. 线程join

![1586943594802](课件\java_concurrency_core\课程资料\happens-before规则之线程join.png)

6. 传递性：如果hb(A, B)而且hb(B, C)，那么可以推出hb(A, C)。

7. 中断：一个线程被其他线程interrupt时，那么检测中断(isInterrupted)或者抛出InterruptedException一定能看到。

8. 构造方法：对象构造方法的最后一行指令happens-before于finalize()的第一条指令。

9. 工具类的Happens-Before原则

   1. 线程安全的容器get一定能看到在此之前的put等存入动作

      ConcurrentHashMap<>()；

   2. CountDownLatch

   3. CyclicBarrier

   4. Semaphore

   5. Future：get()前的结果都是可见的

   6. 线程池：会给线程池提交(submit方法)很多任务，在提交的任务中，每一个任务都能看到提交之前的所有执行结果。

##### volatile关键字

* volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并**不会发生上下文切换**等开销很大的行为。
* 如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能**会被并发修改**。
* 但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是做不到synchronized那样的**原子保护**，volatile仅在**很有限的场景**下才能发挥作用。
* 💡在有volatile修饰的变量，赋值后会执行一个带有lock前缀指令操作`lock addl$0x0`，会将修改同步到内存，意味着在这个指令之前的操作都已经执行完成，形成了“指令重排序无法越过内存屏障”的效果

###### volatile的适用场合

* 不适用：a++，因为volatile只能保证给a赋值后的值对其他线程可见，但是没有原子操作的能力。
* 适用场合1：标记位(boolean flag)，**赋值操作本身是具有原子性**，而volatile又保证了可见性，所以可以保证线程安全；
* 适用场合2：作为刷新之前变量的**触发器**。根据**happens-before规则**，在**读取**被volatile修饰的变量的时候，**写入**该变量之前的操作保证是**最新**的。

![1586955294594](课件\java_concurrency_core\课程资料\volatile作触发器.png)

###### volatile的两点作用

1. 可见性：读取一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会**立即刷入到主内存**。
2. **禁止指令重排序优化**：解决单例双重锁乱序问题。
3. volatile可以**使得long和double的赋值是原子**的。(额外)

###### volatile和synchronized的关系

* volatile可以看做是**轻量级**的synchronized：如果一个共享变量**自始至终只被各个线程赋值**，而没有其他操作，那么就可以用volatile来代替synchronized或者原子变量，因为**赋值自身是具有原子性**的，而**volatile又保证了可见性**，所以能够保证线程安全。

##### 能保证可见性的措施

* 除了volatile可以让变量保证可见性之外，synchronized、Lock、并发集合、Thread.join()和Thread.start()等都可以保证可见性；
* 具体看happens-before规则

##### 升华：对synchronized可见性的正确理解

* synchronized不仅保证了原子性，还保证了可见性；
* synchronized不仅让被保护的代码安全，还**近朱者赤**。

#### 原子性

* 什么是原子性
* Java中的原子操作有哪些？
* long和double的原子性
* 原子操作 + 原子操作 != 原子操作

##### 什么是原子性

* 一系列的操作，**要么全部执行成功，要么全部不执行**，不会出现执行一半的情况，这些操作是不可分割的。
* ATM里取钱
* i++不是原子性
* 用synchronized实现原子性

##### Java中的原子操作

1. 除long和double之外的基本类型(int, byte, boolean, short, char, float)的赋值操作；
2. 所有引用**reference的赋值操作**，不管是32位的机器还是64位的机器；
3. java.concurrent.Atomic.*包中所有类的原子操作。

##### long和double的原子性

* long和double的值都是64位，为了效率，JVM可能会把64位的值分为两个32位的值各自单独写入。

##### 原子操作的组合

* 简单地把原子操作组合在一起，并不能保证整体依然具有原子性
* **全同步的HashMap也不完全安全**

### 面试常见问题

#### 1. JMM应用实例：单例模式8种写法、单例和并发的关系（面试超高频考点）

##### 单例模式的作用

1. 为什么需要单例：节省内存和计算、保证结果正确、方便管理

##### 单例模式的适用场景

1. 无状态的工具类：比如日志工具，不管是在哪使用，只需要让它记录日志，也不需要在它的实例对象上存储任何状态，这时候就只需要一个实例对象即可。
2. 全局信息类：比如在一个类上记录网站的访问次数，不希望记录分散在各个对象上，此时就应该让这个类成为单例。

##### 单例模式的8中写法

* 单例模式的构造函数都是**私有**的。

###### 1. 饿汉式(静态常量)[可用]

* 优点：
  * 代码简单
  * **类装载的时候就完成了实例化(饿)，类的加载由JVM自身保证线程安全**
* 缺点：由于一开始就加载好，不需要时，会造成资源浪费

###### 2. 饿汉式(静态代码块)

* 优点同上

###### 3. 懒汉式(线程不安全)[不可用]

* 优点：只有用到的时候才去加载，节省内存

###### 4. 懒汉式(线程安全，同步方法)[不推荐用]

* 缺点：效率低，**多个线程不能同时使用这个单例**

###### 5. 懒汉式(线程不安全，同步代码块，单层检查)[不可用]

###### 6. 双重检查[推荐用]

* 优点：线程安全；延迟加载，效率较高。

* 为什么要用volatile？

  * **新建对象实际上有3个步骤**，这些步骤可能会被重排序从而导致NPE异常；

  ```java
  memory = allocate(); //1.分配对象内存空间
  instance(memory);    //2.初始化对象
  instance = memory;   //3.设置instance指向刚分配的内存地址，此时instance！=null
  // 第二三步没有联系，可能被重排序打乱顺序，导致对象没完成初始化就被另一个线程拿到
  ```
  
  ![img](课件\java_concurrency_core\课程资料\单例模式-双重检查.jpg)

###### 7. 静态内部类[推荐]

* 优点：
  * 效率高，只有用到的时候才去加载，节省内存
  * 类装载的时候就完成了实例化(饿)，类的加载由JVM自身保证线程安全

###### 8. 枚举[推荐]

* 代码最简洁

##### 不同写法对比

* 饿汉：简单，但是没有lazy loading
* 懒汉：有线程安全问题
* 静态内部类：可用
* 双重检查：面试用，同时具备了线程安全和懒加载
* 枚举：实际工作最好

##### 实现单例模式最好的方式

* **枚举方式最好**
  * 写法最简单
  * 线程安全
  * 懒加载
  * **避免反序列化破坏单例**
* 非线程同步的方法不能使用；
* 如果程序一开始要加载的资源太多，那么就应该使用懒加载；
* 饿汉式如果是对象的创建需要准备工作(配置文件)就不适用；
* 懒加载虽好，但静态内部类这种方式会引入编程复杂性。

##### 单例模式面试常见问题

* 饿汉式缺点？
* 懒汉式缺点？
* 为什么要用double-check？不用就不安全吗？
  * 从普通懒汉式的缺点出发
* 为什么双重检查模式要用**volatile**？

* 用哪种单例的实现方案最好？

#### 2. 什么是Java内存模型

简要介绍三兄弟 -> 为什么需要JMM -> JMM是规范 -> JMM三个重要性质

#### 3. volatile和synchronized异同？

#### 4. 什么是原子操作?java中有哪些原子操作？生成对象的过程是不是原子操作？

#### 5. 什么是内存可见性？

多级缓存图

#### 6. 64位的double和long写入的时候是原子的吗？



